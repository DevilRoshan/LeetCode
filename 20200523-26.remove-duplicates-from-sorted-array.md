# 26.remove-duplicates-from-sorted-array

> 题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/



### 题目

给定一个排序数组，你需要在**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。



**示例 1:**

```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```



### 解题

#### 思路

* 理清题目，数组原先为一个**排序**的数组，执行完函数后需要返回**数组长度n**，并且将**原数组修改为前n项按序不重复的数组**。换一种方式理解题目，我们需要将数组中**差异项**找出来，并且放在该数组的**前几项**，并且返回**不同项的个数**。例如，``` [0,0,1,1,1,2,2,3,3,4], 0为第一个差异项，第2个0为重复项，1则为第2个差异项，而之后两个重复的1则为重复项，我们就是要找出差异项，并且放在对应前几的位置上```
* 那么我们需要一个变量记录该数组中差异项的个数，他就对应数组中的存储最后一个差异项的下标+1。因为需要修改原先数组的项，所以我们可以直接记录存储差异项的数组下标，例如，存储在数组的第0项的就是第1个差异项，存储在数组的第1项就是第2个差异项，最后返回最后一个差异项的下标+1
* 因为数组是有序的，所以重复项是在一起的。因此，我们遍历数组时，可以通过判断当前项和上一个差异项是否相同来判断是否当前项为差异项，如果相同则说明是重复项，则跳过记录
* 这也就是快慢指针，快指针遍历数组，慢指针指向最后一个差异项。快指针指向的遍历的当前项与最后一个差异项进行比较，如果相同，则说明重复项没有遍历完成，如果不同，则说明该差异项的重复项已经遍历完了。则将新的慢指针向后移动，并且记录新的差异项。

#### 代码

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  if(nums.length < 2) return nums.length;
  var j = 0
  for(var i = 1; i < nums.length; i++){
    if(nums[j] !== nums[i]){
    	nums[++j] = nums[i] 
    }
  }
  return j+1
};
```



### 思考

* 对于引用类型，要习惯指针的思考方式
* 因为数组是排序的，所以判断较为简单，如果数组不是有序的，则需要添加重复项的判断



> 其他参考链接：https://github.com/azl397985856/leetcode/blob/master/problems/26.remove-duplicates-from-sorted-array.md