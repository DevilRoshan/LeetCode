# 36.valid-sudoku

> 题目链接：https://leetcode-cn.com/problems/valid-sudoku/
>



### 题目

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

* 数字 1-9 在每一行只能出现一次。
* 数字 1-9 在每一列只能出现一次。
* 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

示例 1:

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

示例 2:

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

说明:

* 一个有效的数独（部分已被填充）不一定是可解的。
* 只需要根据以上规则，验证已经填入的数字是否有效即可。
* 给定数独序列只包含数字 1-9 和字符 '.' 。
* 给定数独永远是 9x9 形式的。



### 解题

#### 思路[1]HashMap

* 使用hashMap存储数据，存储每行/每列/每个3x3 宫中每个数是否出现过
* 遍历二维数组，检查从map中查询该数是否出现过，出现过直接return false，没有出现过则将其添加到map中。
* 遍历完成依然没有重复则说明数独有效。

#### 代码

```
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  let map = {
    l: [],
    c: [],
    lc: [],
  };
  for(var i = 0; i < board.length; i++){
    let line = board[i];
    map.l[i] = {}
    for(var j = 0; j < line.length; j++){
      let num = line[j];
      if(num === '.'){
        continue; 
      }
      let k = Math.floor(i / 3) * 3 + Math.floor(j / 3);
      if(!map.c[j]) {
        map.c[j] = {}
      }
      if(!map.lc[k]){
        map.lc[k] = {}
      }
      if(map.l[i][num] || map.c[j][num] || map.lc[k][num]){
        return false
      }
      map.l[i][num] = map.c[j][num] = map.lc[k][num] = true;
    }
  }
  return true
};
```

#### 思路[2]位运算

* 数独中，一共有9个数，每个数某列/某行/某3x3 宫只会出现一次，我们需要的就是记录这些就可以了。每个数字对应1-9列，1-9行，1-9宫。
* 我们用二维数组记录这个结果，第一维数组的下标表示1-9的数字，第二维数组的下标表示列/行/宫，二维数组中的每个数字表示是否出现过。比如，`arr[i][j] = 7`，表示i这个数字，在第j列/行/宫，的标示是7。7这个数字具体的含义看下一步
* 二进制`&`运算表示对两个二进制数来说，逐位进行判断，相同则为1，不同则为0，也就是说`0b0100&0b0100 => 0b0100  0b0001&0b0010 => 0b0000`。
* 根据这个特点，用二进制的从右往左看的第一位表示是否出现在该行，第二位表示是否出现在该列，第三位表示是否出现在该3x3宫，那么，通过位数组合，表示该数出现在该行该列该矩阵，比如``` 0b0001 => 1 // 出现在该行，0b0010 => 2 // 出现在该列 0b0011 => 1+2 => 3//出现在该行该列```，最后通过`&`运算来进行判断时候重复。

#### 代码

```
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
	let arr = new Array(9).fill(0).map((ele) => new Array(9).fill(0));
  for(let i = 0; i < 9; i++) {
    for(let j = 0; j < 9; j++) {
      if(isNaN(board[i][j])) {
        continue 
      }
      let k = Math.floor(i / 3) * 3 + Math.floor(j / 3),
      val = board[i][j] - 1;
      if((arr[val][i]&1) || (arr[val][j]&2 || (arr[val][k]&4))) return false;
      arr[val][i] += 1;
      arr[val][j] += 2;
      arr[val][k] += 4;
    }
  }
  return true;
}
```

#### 

### 思考

* 解决数组问题通过额外的hashMap会使问题更简单，找到需要记录的关系是什么，会使问题变得轻松
* 位运算的储存方式可以学习，但确实不太容易想到