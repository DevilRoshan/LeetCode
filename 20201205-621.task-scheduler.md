# 621.task-scheduler

> 题目链接：https://leetcode-cn.com/problems/task-scheduler/
>
> 参考链接：
>

### 题目

给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 **相同种类** 的任务之间必须有长度为整数 `n` 的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 **最短时间** 。

**示例 1:**

```
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
```

**示例 2:**

```
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类
```

**示例 3:**

```
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
```

**提示：**

1. `1 <= task.length <= 104`
2. `tasks[i]` 是大写英文字母
3. `n` 的取值范围为 `[0, 100]`



### 解题

#### 思路[1]模拟

* 

#### 代码

```javascript
/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function(tasks, n) {
  const freq = _.countBy(tasks);

  // 任务总数
  const m = Object.keys(freq).length;
  const nextValid = new Array(m).fill(1);
  const rest = Object.values(freq);

  let time = 0;
  for (let i = 0; i < tasks.length; i++) {
    time++;
    let minNextValid = Number.MAX_VALUE;
    for (let j = 0; j < m; j++) {
        if (rest[j] > 0) {
          minNextValid = Math.min(nextValid[j], minNextValid);
        }
    }
    time = Math.max(time, minNextValid);

    let best = -1;
    for (let j = 0; j < m; j++) {
      if (rest[j] && nextValid[j] <= time) {
        if (best === -1 || rest[j] > rest[best]) {
          best = j;
        }
      }
    }

    nextValid[best] = time + n + 1;
    rest[best]--;
  }
  return time;
};
```

#### 思路[2]分组

* 直接将数组分组，遍历统计数量，如果当前数字`x`的数量大于了`x-1`的数量，则说明是新组，就在之前放入一个数组
* 这样就保证了每个数字如果不连续，就会新开一个子序列数组缓存这个数字
* 而如果数字连续，而后一个比前一个数量多，就将多的那个单独存储在一个序列里，而它之后的数字，优先放入这个单独的新序列中，保证优先填充短的序列，如果有多的，就接着向以前的序列填充
* 有这个思路的根本在于数字数量，与它要填充到那个子序列是相关的，且优先是要放入短的序列

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var isPossible = function(nums) {
  const arr = [], map = {};
  for(let num of nums){
    let count = (map[num] || 0) + 1;
    let index = count - 1;
    if(count > (map[num - 1] || 0)){
      arr.unshift([]);
      index = 0;
    }
    arr[index].push(num);
    map[num] = count;
  }
  return arr.every(item => {
    const length = item.length
    if(length < 3){
      return false
    }
    for(let i = 1; i < length; i++){
      if(item[i] - item[i - 1] !== 1){
        return false
      }
    }
    return true
  })
};
```



### 思考

