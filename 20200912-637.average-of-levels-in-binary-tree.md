# 637.average-of-levels-in-binary-tree

> 题目链接：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/
>
> 参考链接：

### 题目

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

**示例  :**

```
输入：
    3
   / \
  9  20
    /  \
   15   7
输出：[3, 14.5, 11]
解释：
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。
```

**提示：**

- 节点值的范围在32位有符号整数范围内。



### 解题

#### 思路[1]深度优先遍历

* 其根本也是层序遍历，只是层序遍历将该层的和求出，该层的数量记录下来，然后计算均值即可

#### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function(root) {
  const ans = [];
  const helper = (node, level) => {
    if(!node){
      return
    }
    let ansCache = ans[level] || {val: 0, count: 0};
    ansCache.val = ansCache.val +  node.val;
    ansCache.count = ansCache.count + 1;
    ans[level] = ansCache;
    helper(node.left, level+1)
    helper(node.right, level+1)
  }
  helper(root, 0)
  return ans.map(v => (v.val / v.count))
};
```

#### 思路[2]二进制枚举

* 将所有情况记录为二进制数据，每位0代表不选择，1代表选择， 这样所有情况的数量是确定的
* 当通过二进制数得到所有所有数字时，可以判断选择的数字是否满足情况，如果满足则放入结果中

#### 代码

```javascript
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
  let temp = [];
  const ans = [];
  const check = (mask, k, n) => {
    temp = [];
    // 将二进制数转化为数字
    for (let i = 0; i < 9; ++i) {
      if ((1 << i) & mask) {
        temp.push(i + 1);
      }
    }
    return temp.length === k && temp.reduce((previous, value) => previous + value, 0) === n;
  }

  for (let mask = 0; mask < (1 << 9); ++mask) {
    if (check(mask, k, n)) {
      ans.push(temp);
    }
  }
  return ans;
};
```

#### 

### 思考

