# 213.house-robber-ii

> 题目链接：https://leetcode-cn.com/problems/house-robber-ii/
>
> 参考链接：https://leetcode-cn.com/problems/largest-number/solution/zui-da-shu-by-leetcode-solution-sid5/

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，能够偷窃到的最高金额。

**示例 1 :**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2 :**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3 :**

```
输入：nums = [0]
输出：0
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`



### 解题

#### 思路[1]动态规划

虽然是两种代码结构，但实际上是同一种思路即进行两种。

首先先处理房子数量少的情况

* 数量为1，则直接返回
* 数量为2，则返回较大的

然后是数量超过两个的时候，最后一个和第一个是互斥的，所以两种情况。

* 如果偷窃第一个，则要排除考虑最后一个，所以从 `0 -> length - 2`
* 如果偷窃最后一个，则要排除考虑第一个，所以从 `1 -> length - 1`

对于每一个过程，都一样，即使用动态规划，当前的最大数量，等于选择当前值和不选择当前值两种情况的最大值

* 如果选择当前值，则不能选择前一个，所以，为 `dp[i - 2] + nums[i]`
* 如果不选择当前值，则他最大值就是前一个的最大值，至于前一个是否选择，在前一个选择的过程中就已经处理了，所以，为 `dp[i - 1]`

至于还有一些情况，仔细思考也能得出

* 比如，在考虑第一个的情况中，也会出现，既不选第一个也不选倒数第二的情况，这个时候应该选择最后一个。这种情况看似不在递推过程中，但实际上在考虑偷窃最后一个的时候这种情况也包含在内了

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
// dp数组版
var rob = function(nums) {
  const length = nums.length;
  if(length === 1) {
    return nums[0]
  }
  let max = Math.max(nums[0], nums[1])
  if(length === 2){
    return max
  }
  let dp1 = [nums[0], max], dp2 = [0, nums[1]];
  for(let i = 2; i < length - 1; i++){
    dp1[i] = Math.max(dp1[i - 1], dp1[i - 2] + nums[i])
    dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i])
  }
  const last = length - 1;
  return Math.max(dp1[last - 1], dp2[last - 1], dp2[last - 2] + nums[last])
};

/**
 * @param {number[]} nums
 * @return {number}
 */
// 变量代替数组
var rob = function(nums) {
  const length = nums.length;
  if(length === 1) {
    return nums[0]
  }
  let max = Math.max(nums[0], nums[1])
  if(length === 2){
    return max
  }
  let first1 = nums[0], second1 = max, first2 = 0, second2 = nums[1];
  for(let i = 2; i < length - 1; i++){
    let temp = second1;
    second1 = Math.max(first1 + nums[i], second1);
    first1 = temp;
    temp = second2;
    second2 = Math.max(first2 + nums[i], second2);
    first2 = temp;
  }
  return Math.max(second1, first2 + nums[length - 1], second2)
};

/**
 * @param {number[]} nums
 * @return {number}
 */
// 分批计算
var rob = function (nums) {
  const length = nums.length;
  if (length === 1) {
    return nums[0];
  } else if (length === 2) {
    return Math.max(nums[0], nums[1]);
  }
  return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));
};

const robRange = (nums, start, end) => {
  let first = nums[start], second = Math.max(nums[start], nums[start + 1]);
  for (let i = start + 2; i <= end; i++) {
    const temp = second;
    second = Math.max(first + nums[i], second);
    first = temp;
  }
  return second;
}
```



### 思考

* 现在看来，动态规划比较重要的找到递推公式，大多数递推公式都是要分情况讨论的，所以可以从这个角度进行考虑，也就是上题的思路，先将总情况分为两种，然后再将每种情况最为一个递推过程考虑，最后汇总得到最终结果